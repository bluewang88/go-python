package Go_base

import (
	"fmt"
)

func HelloSlice2() {
	slice := []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
	s1 := slice[2:5] //切片从索引2到索引5（不包括5），容量为8
	fmt.Println("s1 := slice[2:5]的值为", s1)
	fmt.Println("s1在append之前的长度为", len(s1))
	fmt.Println("s1在append之前的容量为", cap(s1))
	//在Go语言中，当从一个现有切片创建新切片时，新切片的容量默认是从起始索引到原切片末尾的元素总数，而不仅仅是新切片的长度。
	// 这种设计的好处
	// 内存效率：
	// 避免频繁的内存分配和复制
	// 当使用append向s1添加元素时，可以直接利用已分配的空间
	// 避免了内存碎片化

	// 性能优势：
	// 减少了内存分配操作
	// 减少了垃圾回收压力

	// 灵活性：
	// 允许切片在不重新分配内存的情况下动态增长
	// 能够通过再切片轻松访问原始数据的更多部分

	// 共享底层存储：
	// 多个切片可以高效地共享同一个底层数组

	s2 := s1[2:6:7] //切片从索引2到索引6（不包括6），容量为5 ，7只是限制了新切片的容量
	/*
		     * s2 := s1[low:high:max]
			 * low: 起始索引，包含该元素
			 * high: 结束索引，不包含该元素（决定长度）
			 * max: 容量上限索引，决定新切片的容量
			 * 在三索引切片语法 s2 := s1[low:high:max] 中，容量的计算公式是 max - low。
			 * 根据三索引切片的规则：

			 * s2 的长度 = high - low = 6 - 2 = 4
			 * s2 的容量 = max - low = 7 - 2 = 5
	*/

	s2 = append(s2, 100)
	fmt.Println("s2 = append(s2, 100)的值为", s2)
	fmt.Println("s2在append之后的长度为", len(s2))
	fmt.Println("s2在append之后的容量为", cap(s2))
	fmt.Println("s2在append之后的长度为s1的值为", s1) //打印 s1 的时候，只会打印出 s1 长度以内的元素。所以，只会打印出3个元素，虽然它的底层数组不止3个元素。

	// 打印s1的标准视图和完整底层数组
	fmt.Println("s1标准视图:", s1) // 只显示长度内的元素
	s1Full := s1[:cap(s1)]
	fmt.Println("s1完整底层数组:", s1Full) // 显示所有容量内的元素

	fmt.Println("s2在append之后的长度为slice的值为", slice)

	s2 = append(s2, 200) //容量翻倍
	// 这里的容量翻倍是因为在Go语言中，当切片的容量不足以容纳新元素时，Go会自动分配一个新的底层数组，并将原数组的元素复制到新数组中。
	// 这个新数组的容量通常是原数组容量的两倍，以减少未来的内存分配次数。
	// 这就是为什么在append操作后，s2的长度和容量都发生了变化，而s1的长度和容量保持不变的原因。因为s2已经变成了新的切片，指向了新的底层数组。

	s1[2] = 20

	fmt.Println(s1)
	fmt.Println(s2)
	fmt.Println(slice)
}
