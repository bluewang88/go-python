package Go_base

import (
	"fmt"
)

// 信道是带有类型的管道，你可以通过它用信道操作符 <- 来发送或者接收值。

// ch <- v    // 将 v 发送至信道 ch。
// v := <-ch  // 从 ch 接收值并赋予 v。
// （“箭头”就是数据流的方向。）

// 和映射与切片一样，信道在使用前必须创建：

// ch := make(chan int)
// 默认情况下，发送和接收操作在另一端准备好之前都会阻塞。这使得 Go 程可以在没有显式的锁或竞态变量的情况下进行同步。

// 以下示例对切片中的数进行求和，将任务分配给两个 Go 程。一旦两个 Go 程完成了它们的计算，它就能算出最终的结果。

func sum(s []int, c chan int) {
	sum := 0
	for _, v := range s {
		sum += v
	}
	c <- sum // 发送 sum 到 c
}
func Hello_channel() {
	s := []int{7, 2, 8, -9, 4, 0}

	c := make(chan int)
	go sum(s[:len(s)/2], c)
	go sum(s[len(s)/2:], c)
	x, y := <-c, <-c // 从 c 接收

	fmt.Println(x, y, x+y)
}

// package Go_base

// import (
// 	"fmt"
// )

// 信道是带有类型的管道，你可以通过它用信道操作符 <- 来发送或者接收值。
// 信道是 Go 语言中用于 Goroutine 之间通信的核心机制，类似于其他语言中的消息队列或管道。
// 信道的类型决定了可以发送和接收的数据类型，例如 `chan int` 表示只能传递 `int` 类型的数据。

// ch <- v    // 将 v 发送至信道 ch。
// v := <-ch  // 从 ch 接收值并赋予 v。
// （“箭头”就是数据流的方向。）

// 和映射与切片一样，信道在使用前必须创建：
// ch := make(chan int)
// 默认情况下，发送和接收操作在另一端准备好之前都会阻塞。这使得 Go 程可以在没有显式的锁或竞态变量的情况下进行同步。

// 以下示例对切片中的数进行求和，将任务分配给两个 Go 程。一旦两个 Go 程完成了它们的计算，它就能算出最终的结果。

// sum 函数接收一个整数切片 s 和一个整数类型的信道 c
// func sum(s []int, c chan int) {
// 	sum := 0
// 	// 遍历切片 s，累加所有元素的值
// 	for _, v := range s {
// 		sum += v
// 	}
// 	// 将累加结果发送到信道 c
// 	c <- sum // 发送 sum 到 c
// }

// // Hello_channel 是程序的入口函数
// func Hello_channel() {
// 	// 创建一个整数切片 s，包含 6 个元素
// 	s := []int{7, 2, 8, -9, 4, 0}

// 	// 创建一个整数类型的信道 c
// 	c := make(chan int)
// 	// 启动第一个 Goroutine，计算切片 s 的前半部分的和，并将结果发送到信道 c
// 	go sum(s[:len(s)/2], c)
// 	// 启动第二个 Goroutine，计算切片 s 的后半部分的和，并将结果发送到信道 c
// 	go sum(s[len(s)/2:], c)
// 	// 从信道 c 接收两个值，分别赋值给 x 和 y
// 	// 注意：接收操作会阻塞，直到有数据可接收
// 	x, y := <-c, <-c // 从 c 接收

// 	// 打印两个部分的和以及它们的总和
// 	fmt.Println(x, y, x+y)
// }
